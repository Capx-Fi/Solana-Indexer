import * as anchor from "@project-serum/anchor";
import {
    Program,
    EventParser
} from "@project-serum/anchor";
import {
    Connection,
    PublicKey,
    clusterApiUrl
} from "@solana/web3.js";
const axios = require('axios');
import { IDL } from "../idls/::::PROGRAM_NAME_ts";
import NodeWallet from "@project-serum/anchor/dist/cjs/nodewallet";

let connection = new Connection("::::CLUSTER_URL","finalized");
let keyPair = anchor.web3.Keypair.generate();
let nodeWallet = new NodeWallet(keyPair);

let provider = new anchor.AnchorProvider(connection, nodeWallet, {commitment: "finalized"});
let program = new Program( IDL , "::::PROGRAM_ID", provider);
let eventParser = new EventParser( new PublicKey("::::PROGRAM_ID"), program.coder);

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

let logs : Map<number,string[]> = new Map()
let unprocessedLogs : number[] = []
let recSlot = ::::START_SLOT

// AWS Config
import * as AWS from "aws-sdk";
// Set the region 
AWS.config.update({region: 'us-east-1'});

// Create the DynamoDB service object
var ddb = new AWS.DynamoDB({apiVersion: '2012-08-10'});

async function getBlockDetails() {
    let flag = true
    while (flag) {
        let x = await getSlot("devnet", "finalized");
        if (x - recSlot < 1000 && x - recSlot > 500) {
            await sleep(4000)
        } else if (x - recSlot < 500) {
            await sleep(10000)
        }
        while (x - recSlot > 1000) {
            await populateLogs(recSlot)
            recSlot += 100
            if (logs.size > 10000) {
                await sleep(1000)
            } else {
                await sleep(150)
            }
        }
    }
}

async function populateLogs(slot) {
    try {
        let slots : number[] = []
        let keys : { slot: { N: string; }; }[] = []
        for (let index = 0; index < 100; index++) {
            keys.push({'slot': {N: (slot + index).toString()}})
            
        }
        var params = {
            RequestItems: {
                '::::NETWORK-blocks': {
                    Keys: keys,
                }
            }
        };
        let data = await ddb.batchGetItem(params).promise();
        
        data.Responses!['::::NETWORK-blocks'].forEach(function(element, index, array) {
            let temp : string[] = []
            
            element["blockLogs"].L?.map((log: any) => {
                if (log.S) {
                    temp.push(log.S);
                    
                }
            })
            logs.set(parseInt(element["slot"].N!),temp)
            slots = slots.filter((item) => item !== parseInt(element["slot"].N!))
        });
        unprocessedLogs = unprocessedLogs.concat(slots)
    } catch (error) {
        console.log(error);
        
    }
}

async function getSlot(_network: string, _commitment: string) {
    var data = JSON.stringify({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getSlot",
        "params": [
          {
            "commitment": _commitment
          }
        ]
    });
    var config = {
        method: 'post',
        url: "https://solana-devnet.g.alchemy.com/v2/FN-j_DEecftJ-VAtcMzD72gzueeb82Mz",
        headers: { 
          'Content-Type': 'application/json'
        },
        data : data
    };
    return axios(config)
    .then(function (response) {
        return response.data.result;
    })
    .catch(function (error) {
        console.log(error);
    });
}

const getEventObject = async(slot: number) => {
    let flag = true;
    while(flag){
        console.log("Slot ",slot);        
        while (slot < recSlot) {
            if (logs.get(slot) === undefined) {
                if (unprocessedLogs.includes(slot)) {
                    unprocessedLogs = unprocessedLogs.filter((item) => item !== slot)
                    slot+= 1
                }
            console.log("waiting");
            await sleep(1000)
        } else {
            console.log("processing");
            
            for (const _event of eventParser.parseLogs(logs.get(slot)!)) {
                console.log("Event",_event);
                let eventObj = {
                     name : _event.name,
                     params : _event.data
                }
                await handleEvents(eventObj)
            }
            logs.delete(slot)
            console.log(slot);
            
            slot += 1;
        }
        }
        await sleep(5000)
    }
}

getEventObject(::::START_SLOT);
getBlockDetails()