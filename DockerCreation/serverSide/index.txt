import {
	handleU64Event,
	handleStringEvent,
	handlePubkeyEvent,
	handleU8Event,
} from '../src/mapping';

import {
	U64Event,
	StringEvent,
	PubkeyEvent,
	U8Event,
} from './Interfaces';

import * as anchor from "@project-serum/anchor";
import {
    Program,
    EventParser
} from "@project-serum/anchor";
import {
    Connection,
    PublicKey,
    clusterApiUrl
} from "@solana/web3.js";
const axios = require('axios');
import { IDL } from "../idls/::::PROGRAM_NAME_ts";
import NodeWallet from "@project-serum/anchor/dist/cjs/nodewallet";

let connection = new Connection("::::CLUSTER_URL","finalized");
let keyPair = anchor.web3.Keypair.generate();
let nodeWallet = new NodeWallet(keyPair);

let provider = new anchor.AnchorProvider(connection, nodeWallet, {commitment: "finalized"});
let program = new Program( IDL , "::::PROGRAM_ID", provider);
let eventParser = new EventParser( new PublicKey("::::PROGRAM_ID"), program.coder);

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

let logs : Map<number,string[]> = new Map()
let recSlot = ::::START_SLOT

// AWS Config
import * as AWS from "aws-sdk";
// Set the region 
AWS.config.update({region: 'us-east-1'});

// Create the DynamoDB service object
var ddb = new AWS.DynamoDB({apiVersion: '2012-08-10'});

async function getBlockDetails() {
    let flag = true
    while (flag) {
        populateLogs(recSlot)
        recSlot += 100
        if (logs.size > 10000) {
            await sleep(1000)
        } else {
            await sleep(150)
        }
    }
    
}

async function populateLogs(slot) {
    try {
        let keys : { slot: { N: string; }; }[] = []
        for (let index = 0; index < 100; index++) {
            keys.push({'slot': {N: (slot + index).toString()}})
            
        }
        var params = {
            RequestItems: {
                '::::NETWORK-blocks': {
                    Keys: keys,
                }
            }
        };
        let data = await ddb.batchGetItem(params).promise();
        
        data.Responses!['::::NETWORK-blocks'].forEach(function(element, index, array) {
            let temp : string[] = []
            
            element["blockLogs"].L?.map((log: any) => {
                if (log.S) {
                    temp.push(log.S);
                    
                }
            })
            logs.set(parseInt(element["slot"].N!),temp)
        });
    } catch (error) {
        console.log(error);
        
    }
}

async function getSlot(_network: string, _commitment: string) {
    var data = JSON.stringify({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getSlot",
        "params": [
          {
            "commitment": _commitment
          }
        ]
    });
    var config = {
        method: 'post',
        url: "https://solana-devnet.g.alchemy.com/v2/FN-j_DEecftJ-VAtcMzD72gzueeb82Mz",
        headers: { 
          'Content-Type': 'application/json'
        },
        data : data
    };
    return axios(config)
    .then(function (response) {
        return response.data.result;
    })
    .catch(function (error) {
        console.log(error);
    });
}

const getEventObject = async(slot: number) => {
    let flag = true;
    while(flag){
        let x = await getSlot("devnet", "finalized");
        if(x - slot < 200 && x - slot > 50){
            await sleep(2)
        } else if (x - slot < 50) {
            await sleep(5)
        }
        console.log("Slot ",slot);
        while (logs.size < 1000) {
            console.log("WAITING!");
            console.log(logs.size);
            await sleep(1000)
        }
        // let logs = await getSlotDetails("finalized",slot);
        
        if (logs.get(slot) === undefined) {
            console.log("waiting");
            await sleep(1000)
        } else {
            console.log("processing");
            
            for (const _event of eventParser.parseLogs(logs.get(slot)!)) {
                console.log("Event",_event);
                let eventObj = {
                     name : _event.name,
                     params : _event.data
                }
                await handleEvents(eventObj)
            }
            logs.delete(slot)
            console.log(slot);
            
            slot += 1;
            // await sleep(20000);
        }
    }
}

getEventObject(::::START_SLOT);
getBlockDetails()